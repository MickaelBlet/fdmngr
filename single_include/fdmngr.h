// Generated by amalgamate.py
#ifndef AMALGAMATE_GUARD__SINGLE_INCLUDE_FDMNGR_H_
#define AMALGAMATE_GUARD__SINGLE_INCLUDE_FDMNGR_H_

// -----------------------------
// Start include/fdmngr_socket.h
// -----------------------------

#ifndef FDMNGR_SOCKET_H_
#define FDMNGR_SOCKET_H_

#include <arpa/inet.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Create a TCP socket.
 * @param ip The IP address to bind to.
 * @param port The port number to bind to (0 for any available port).
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create_tcp(const char* ip, int port);

/**
 * @brief Create a UDP socket.
 * @param ip The IP address to bind to.
 * @param port The port number to bind to (0 for any available port).
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create_udp(const char* ip, int port);

/**
 * @brief Create a TCP socket with SO_REUSEADDR option.
 * @param ip The IP address to bind to.
 * @param port The port number to bind to (0 for any available port).
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create_tcp_reuseaddr(const char* ip, int port);

/**
 * @brief Create a UDP socket with SO_REUSEADDR option.
 * @param ip The IP address to bind to.
 * @param port The port number to bind to (0 for any available port).
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create_udp_reuseaddr(const char* ip, int port);

/**
 * @brief Create a TCP IPv6 socket.
 * @param ip The IPv6 address to bind to.
 * @param port The port number to bind to (0 for any available port).
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create_tcp_ipv6(const char* ip, int port);

/**
 * @brief Create a UDP IPv6 socket.
 * @param ip The IPv6 address to bind to.
 * @param port The port number to bind to (0 for any available port).
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create_udp_ipv6(const char* ip, int port);

/**
 * @brief Create a TCP IPv6 socket with SO_REUSEADDR option.
 * @param ip The IPv6 address to bind to.
 * @param port The port number to bind to (0 for any available port).
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create_tcp_ipv6_reuseaddr(const char* ip, int port);

/**
 * @brief Create a UDP IPv6 socket with SO_REUSEADDR option.
 * @param ip The IPv6 address to bind to.
 * @param port The port number to bind to (0 for any available port).
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create_udp_ipv6_reuseaddr(const char* ip, int port);

/**
 * @brief Create a Unix domain stream socket.
 * @param path The file system path for the socket.
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create_unix_stream(const char* path);

/**
 * @brief Create a Unix domain datagram socket.
 * @param path The file system path for the socket.
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create_unix_dgram(const char* path);

enum fdmngr_socket_type_e {
    FDMNGR_SOCKET_TYPE_TCP = 0,
    FDMNGR_SOCKET_TYPE_UDP = 1,
    FDMNGR_SOCKET_TYPE_TCP_REUSEADDR = 2,
    FDMNGR_SOCKET_TYPE_UDP_REUSEADDR = 3,
    FDMNGR_SOCKET_TYPE_TCP_IPV6 = 4,
    FDMNGR_SOCKET_TYPE_UDP_IPV6 = 5,
    FDMNGR_SOCKET_TYPE_TCP_IPV6_REUSEADDR = 6,
    FDMNGR_SOCKET_TYPE_UDP_IPV6_REUSEADDR = 7,
    FDMNGR_SOCKET_TYPE_UNIX_STREAM = 8,
    FDMNGR_SOCKET_TYPE_UNIX_DGRAM = 9
};

/**
 * @brief Create a socket of the specified type.
 *
 * For TCP and UDP types, the function expects two additional arguments:
 * - const char* ip: The IP address to bind to.
 * - int port: The port number to bind to.
 *
 * For Unix domain socket types, the function expects one additional argument:
 * - const char* path: The file system path for the socket.
 *
 * @param type The type of socket to create (see enum fdmngr_socket_type_e).
 * @return The socket file descriptor, or -1 on error.
 */
int fdmngr_socket_create(enum fdmngr_socket_type_e type, ...);

/**
 * @brief Connect a socket to a specified IP address and port.
 * @param socket The socket file descriptor to connect.
 * @param ip The IP address to connect to.
 * @param port The port number to connect to.
 * @return 0 on success, -1 on error.
 */
int fdmngr_socket_connect(int socket, const char* ip, int port);

/**
 * @brief Connect a socket to a specified IPv6 address and port.
 * @param socket The socket file descriptor to connect.
 * @param ip The IPv6 address to connect to.
 * @param port The port number to connect to.
 * @return 0 on success, -1 on error.
 */
int fdmngr_socket_connect_ipv6(int socket, const char* ip, int port);

/**
 * @brief Extract IPv4 address and port from a sockaddr_in structure.
 * @param in The sockaddr_in structure to extract information from.
 * @param out_ip The output buffer for the IPv4 address (4 bytes).
 * @param out_port The output pointer for the port number.
 */
void fdmngr_socket_get_ipv4_infos(struct sockaddr_in in, uint8_t out_ip[4],
                                  uint16_t* out_port);

#ifdef __cplusplus
}
#endif

#endif /* #ifndef FDMNGR_SOCKET_H_ */

// ---------------------------
// End include/fdmngr_socket.h
// ---------------------------

// ---------------------------
// Start include/fdmngr_tool.h
// ---------------------------

#ifndef FDMNGR_TOOL_H_
#define FDMNGR_TOOL_H_

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Get flags to a file descriptor
 *
 * @param fd File descriptor
 * @return int the current flags on success, -1 on failure
 */
int fdmngr_tool_get_flags(int fd);

/**
 * @brief Set flags to a file descriptor
 *
 * @param fd File descriptor
 * @param flags Flags to set (e.g., O_NONBLOCK)
 * @return int the new flags on success, -1 on failure
 */
int fdmngr_tool_set_flags(int fd, int flags);

/**
 * @brief Add flags to a file descriptor
 *
 * @param fd File descriptor
 * @param flags Flags to add (e.g., O_NONBLOCK)
 * @return int the new flags on success, -1 on failure
 */
int fdmngr_tool_add_flags(int fd, int flags);

/**
 * @brief Sub flags to a file descriptor
 *
 * @param fd File descriptor
 * @param flags Flags to sub (e.g., O_NONBLOCK)
 * @return int the new flags on success, -1 on failure
 */
int fdmngr_tool_sub_flags(int fd, int flags);

#ifdef __cplusplus
}
#endif

#endif /* #ifndef FDMNGR_TOOL_H_ */

// -------------------------
// End include/fdmngr_tool.h
// -------------------------

// ----------------------
// Start include/fdmngr.h
// ----------------------

#ifndef FDMNGR_H_
#define FDMNGR_H_

#include <fcntl.h>
#include <features.h>
#include <pthread.h>

#ifdef _POSIX_VERSION
#if _POSIX_VERSION >= 200112L
#define FDMNGR_HAVE_POLL 1
#endif
#endif

#ifdef FDMNGR_HAVE_POLL

#include <poll.h>

#else

#include <sys/select.h>
#include <sys/time.h>
#include <unistd.h>

#define POLLIN 0x0001   /* There is data to read. */
#define POLLPRI 0x0002  /* There is urgent data to read. */
#define POLLOUT 0x0004  /* Writing now will not block. */
#define POLLERR 0x0008  /* Error condition. */
#define POLLHUP 0x0010  /* Hung up. */
#define POLLNVAL 0x0020 /* Invalid polling request. */

/* Data structure describing a polling request. */
struct pollfd {
    int fd;        /* file descriptor */
    short events;  /* requested events */
    short revents; /* returned events */
};

/* Type used for the number of file descriptors. */
typedef unsigned long nfds_t;

#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct fdmngr fdmngr_t;
typedef struct fdmngr_fd fdmngr_fd_t;
typedef void (*fdmngr_poll_callback_t)(fdmngr_t* manager, int fd, short revents,
                                       void* user_data);

enum fdmngr_closing_e {
    FDMNGR_NOT_AUTOMATIC_CLOSING = 0,
    FDMNGR_AUTOMATIC_CLOSING = 1
};

struct fdmngr_fd {
    fdmngr_poll_callback_t poll_callback;
    void* user_data;
    enum fdmngr_closing_e auto_closing;
};

struct fdmngr {
    nfds_t max_nfds;
    nfds_t poll_nfds;
    pthread_mutex_t mutex_fds;
    struct pollfd* poll_fds;
    fdmngr_fd_t* fds;
    int last_errno;
};

/**
 * @brief Create a new file descriptor manager
 *
 * @param max_size Maximum number of file descriptors to manage
 * @return fdmngr_t* Pointer to the created manager, or NULL on failure
 */
fdmngr_t* fdmngr_create(unsigned int max_size);

/**
 * @brief Destroy the file descriptor manager and free resources
 *
 * @param manager Pointer to the manager to destroy
 */
void fdmngr_destroy(fdmngr_t* manager);

/**
 * @brief Add a file descriptor to be managed
 *
 * @param manager Pointer to the manager
 * @param fd File descriptor to add
 * @param events Events to monitor (e.g., POLLIN, POLLOUT)
 * @param closing Closing behavior (automatic or not)
 * @param callback Callback function to invoke on events
 * @param user_data User data to pass to the callback
 * @return 0 on success, -1 on failure
 */
int fdmngr_add(fdmngr_t* manager, int fd, short events,
               enum fdmngr_closing_e closing, fdmngr_poll_callback_t callback,
               void* user_data);

/**
 * @brief Remove a file descriptor from management
 *
 * @param manager Pointer to the manager
 * @param fd File descriptor to remove
 * @return 0 on success, -1 on failure
 */
int fdmngr_remove(fdmngr_t* manager, int fd);

/**
 * @brief Poll the managed file descriptors for events
 *
 * @param manager Pointer to the manager
 * @param timeout_ms Timeout in milliseconds (-1 for infinite)
 * @return Number of file descriptors with events, 0 on timeout, -1 on error
 */
int fdmngr_poll(fdmngr_t* manager, int timeout_ms);

#ifdef __cplusplus
}
#endif

#endif // #ifndef FDMNGR_H_

// --------------------
// End include/fdmngr.h
// --------------------

// -------------------------
// Start src/fdmngr_socket.c
// -------------------------
// #include "fdmngr_socket.h" (already included)

#include <arpa/inet.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>

static inline int s_fdmngr_socket_create_inet(int type, const char* ip,
                                              int port, int reuseaddr) {
    struct sockaddr_in addr;
    int sockfd;
    int yes;

    if (ip == NULL || port < 0 || port > 65535) {
        return -1;
    }

    sockfd = socket(AF_INET, type, 0);
    if (sockfd < 0) {
        return -1;
    }

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    if (inet_pton(AF_INET, ip, &addr.sin_addr) <= 0) {
        close(sockfd);
        return -1;
    }

    if (reuseaddr) {
        /* active re use addr in socket */
        yes = 1;
        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) ==
            -1) {
            close(sockfd);
            return -1;
        }
#ifdef SO_REUSEPORT
        yes = 1;
        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(int)) ==
            -1) {
            close(sockfd);
            return -1;
        }
#endif
    }

    if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        close(sockfd);
        return -1;
    }

    return sockfd;
}

inline int fdmngr_socket_create_tcp(const char* ip, int port) {
    return s_fdmngr_socket_create_inet(SOCK_STREAM, ip, port, 0);
}

inline int fdmngr_socket_create_udp(const char* ip, int port) {
    return s_fdmngr_socket_create_inet(SOCK_DGRAM, ip, port, 0);
}

inline int fdmngr_socket_create_tcp_reuseaddr(const char* ip, int port) {
    return s_fdmngr_socket_create_inet(SOCK_STREAM, ip, port, 1);
}

inline int fdmngr_socket_create_udp_reuseaddr(const char* ip, int port) {
    return s_fdmngr_socket_create_inet(SOCK_DGRAM, ip, port, 1);
}

static inline int s_fdmngr_socket_create_inet6(int type, const char* ip,
                                               int port, int reuseaddr) {
    struct sockaddr_in6 addr6;
    int sockfd;
    int yes;

    if (ip == NULL || port < 0 || port > 65535) {
        return -1;
    }

    sockfd = socket(AF_INET6, type, 0);
    if (sockfd < 0) {
        return -1;
    }

    memset(&addr6, 0, sizeof(addr6));
    addr6.sin6_family = AF_INET6;
    addr6.sin6_port = htons(port);
    if (inet_pton(AF_INET6, ip, &addr6.sin6_addr) <= 0) {
        close(sockfd);
        return -1;
    }

    if (reuseaddr) {
        /* active re use addr in socket */
        yes = 1;
        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) ==
            -1) {
            close(sockfd);
            return -1;
        }
#ifdef SO_REUSEPORT
        yes = 1;
        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(int)) ==
            -1) {
            close(sockfd);
            return -1;
        }
#endif
    }

    if (bind(sockfd, (struct sockaddr*)&addr6, sizeof(addr6)) < 0) {
        close(sockfd);
        return -1;
    }

    return sockfd;
}

inline int fdmngr_socket_create_tcp_ipv6(const char* ip, int port) {
    return s_fdmngr_socket_create_inet6(SOCK_STREAM, ip, port, 0);
}

inline int fdmngr_socket_create_udp_ipv6(const char* ip, int port) {
    return s_fdmngr_socket_create_inet6(SOCK_DGRAM, ip, port, 0);
}

inline int fdmngr_socket_create_tcp_ipv6_reuseaddr(const char* ip, int port) {
    return s_fdmngr_socket_create_inet6(SOCK_STREAM, ip, port, 1);
}

inline int fdmngr_socket_create_udp_ipv6_reuseaddr(const char* ip, int port) {
    return s_fdmngr_socket_create_inet6(SOCK_DGRAM, ip, port, 1);
}

static inline int s_fdmngr_socket_create_unix(int type, const char* path) {
    struct sockaddr_un addr;
    int sockfd;

    if (path == NULL) {
        return -1;
    }

    sockfd = socket(AF_UNIX, type, 0);
    if (sockfd < 0) {
        return -1;
    }

    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);

    if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        close(sockfd);
        return -1;
    }

    return sockfd;
}

inline int fdmngr_socket_create_unix_stream(const char* path) {
    return s_fdmngr_socket_create_unix(SOCK_STREAM, path);
}

inline int fdmngr_socket_create_unix_dgram(const char* path) {
    return s_fdmngr_socket_create_unix(SOCK_DGRAM, path);
}

inline int fdmngr_socket_create(enum fdmngr_socket_type_e type, ...) {
    va_list args;
    va_start(args, type);
    int sockfd;

    const char* ip;
    int port;

    const char* path;

    sockfd = -1;
    switch (type) {
        case FDMNGR_SOCKET_TYPE_TCP: {
            ip = va_arg(args, const char*);
            port = va_arg(args, int);
            sockfd = fdmngr_socket_create_tcp(ip, port);
            break;
        }
        case FDMNGR_SOCKET_TYPE_UDP: {
            ip = va_arg(args, const char*);
            port = va_arg(args, int);
            sockfd = fdmngr_socket_create_udp(ip, port);
            break;
        }
        case FDMNGR_SOCKET_TYPE_TCP_REUSEADDR: {
            ip = va_arg(args, const char*);
            port = va_arg(args, int);
            sockfd = fdmngr_socket_create_tcp_reuseaddr(ip, port);
            break;
        }
        case FDMNGR_SOCKET_TYPE_UDP_REUSEADDR: {
            ip = va_arg(args, const char*);
            port = va_arg(args, int);
            sockfd = fdmngr_socket_create_udp_reuseaddr(ip, port);
            break;
        }
        case FDMNGR_SOCKET_TYPE_TCP_IPV6: {
            ip = va_arg(args, const char*);
            port = va_arg(args, int);
            sockfd = fdmngr_socket_create_tcp_ipv6(ip, port);
            break;
        }
        case FDMNGR_SOCKET_TYPE_UDP_IPV6: {
            ip = va_arg(args, const char*);
            port = va_arg(args, int);
            sockfd = fdmngr_socket_create_udp_ipv6(ip, port);
            break;
        }
        case FDMNGR_SOCKET_TYPE_TCP_IPV6_REUSEADDR: {
            ip = va_arg(args, const char*);
            port = va_arg(args, int);
            sockfd = fdmngr_socket_create_tcp_ipv6_reuseaddr(ip, port);
            break;
        }
        case FDMNGR_SOCKET_TYPE_UDP_IPV6_REUSEADDR: {
            ip = va_arg(args, const char*);
            port = va_arg(args, int);
            sockfd = fdmngr_socket_create_udp_ipv6_reuseaddr(ip, port);
            break;
        }
        case FDMNGR_SOCKET_TYPE_UNIX_STREAM: {
            path = va_arg(args, const char*);
            sockfd = fdmngr_socket_create_unix_stream(path);
            break;
        }
        case FDMNGR_SOCKET_TYPE_UNIX_DGRAM: {
            path = va_arg(args, const char*);
            sockfd = fdmngr_socket_create_unix_dgram(path);
            break;
        }
    }
    va_end(args);
    return sockfd;
}

inline int fdmngr_socket_connect(int socket, const char* ip, int port) {
    struct sockaddr_in addr;

    if (socket < 0 || ip == NULL || port <= 0 || port > 65535) {
        return -1;
    }

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    if (inet_pton(AF_INET, ip, &addr.sin_addr) <= 0) {
        return -1;
    }

    if (connect(socket, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        return -1;
    }

    return 0;
}

inline int fdmngr_socket_connect_ipv6(int socket, const char* ip, int port) {
    struct sockaddr_in6 addr6;

    if (socket < 0 || ip == NULL || port <= 0 || port > 65535) {
        return -1;
    }

    memset(&addr6, 0, sizeof(addr6));
    addr6.sin6_family = AF_INET6;
    addr6.sin6_port = htons(port);
    if (inet_pton(AF_INET6, ip, &addr6.sin6_addr) <= 0) {
        return -1;
    }

    if (connect(socket, (struct sockaddr*)&addr6, sizeof(addr6)) < 0) {
        return -1;
    }

    return 0;
}

inline void fdmngr_socket_get_ipv4_infos(struct sockaddr_in in,
                                         uint8_t out_ip[4],
                                         uint16_t* out_port) {
    uint32_t ip = ntohl(in.sin_addr.s_addr); // convert to host byte order
    out_ip[0] = (ip >> 24) & 0xFF;
    out_ip[1] = (ip >> 16) & 0xFF;
    out_ip[2] = (ip >> 8) & 0xFF;
    out_ip[3] = ip & 0xFF;
    *out_port = htons(in.sin_port);
}

// -----------------------
// End src/fdmngr_socket.c
// -----------------------

// -----------------------
// Start src/fdmngr_tool.c
// -----------------------

#include <fcntl.h>

inline int fdmngr_tool_get_flags(int fd) {
    int sock_opt;

    /* get current flags of the fd */
    sock_opt = fcntl(fd, F_GETFL, 0);
    if (sock_opt < 0) {
        return -1;
    }
    return sock_opt;
}

inline int fdmngr_tool_set_flags(int fd, int flags) {
    int sock_opt;

    /* set new flags to the fd */
    sock_opt = fcntl(fd, F_SETFL, flags);
    if (sock_opt < 0) {
        return -1;
    }
    return sock_opt;
}

inline int fdmngr_tool_add_flags(int fd, int flags) {
    int sock_opt;

    /* get current flags of the fd */
    sock_opt = fdmngr_tool_get_flags(fd);
    if (sock_opt >= 0) {
        sock_opt |= flags;
        /* set new flags to the fd */
        if (fdmngr_tool_set_flags(fd, sock_opt) < 0) {
            return -1;
        }
    }
    else {
        return -1;
    }
    return sock_opt;
}

inline int fdmngr_tool_sub_flags(int fd, int flags) {
    int sock_opt;

    /* get current flags of the fd */
    sock_opt = fdmngr_tool_get_flags(fd);
    if (sock_opt >= 0) {
        sock_opt &= (~flags);
        /* set new flags to the fd */
        if (fdmngr_tool_set_flags(fd, sock_opt) < 0) {
            return -1;
        }
    }
    else {
        return -1;
    }
    return sock_opt;
}

// ---------------------
// End src/fdmngr_tool.c
// ---------------------

// ------------------
// Start src/fdmngr.c
// ------------------
// #include "fdmngr.h" (already included)

#include <errno.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>

inline fdmngr_t* fdmngr_create(unsigned int max_size) {
    fdmngr_t* new_manager;

    if (max_size == 0) {
        return NULL;
    }

    new_manager = (fdmngr_t*)malloc(sizeof(fdmngr_t));
    if (new_manager == NULL) {
        return NULL;
    }
    new_manager->poll_fds =
        (struct pollfd*)malloc(sizeof(struct pollfd) * max_size);
    if (new_manager->poll_fds == NULL) {
        free(new_manager);
        return NULL;
    }
    new_manager->fds = (fdmngr_fd_t*)malloc(sizeof(fdmngr_fd_t) * max_size);
    if (new_manager->fds == NULL) {
        free(new_manager->poll_fds);
        free(new_manager);
        return NULL;
    }
    new_manager->max_nfds = max_size;
    new_manager->poll_nfds = 0;
    pthread_mutex_init(&(new_manager->mutex_fds), NULL);
    return new_manager;
}

inline void fdmngr_destroy(fdmngr_t* manager) {
    nfds_t i;

    for (i = 0; i < manager->poll_nfds; i++) {
        if (manager->fds[i].auto_closing == FDMNGR_AUTOMATIC_CLOSING) {
            close(manager->poll_fds[i].fd);
        }
    }
    if (manager->poll_fds != NULL) {
        free(manager->poll_fds);
    }
    if (manager->fds != NULL) {
        free(manager->fds);
    }
    pthread_mutex_destroy(&(manager->mutex_fds));
    free(manager);
}

inline int fdmngr_add(fdmngr_t* manager, int fd, short events,
                      enum fdmngr_closing_e closing,
                      fdmngr_poll_callback_t callback, void* user_data) {
    nfds_t i;

    if (fd < 0 || events == 0 || callback == NULL) {
        return -1;
    }

    pthread_mutex_lock(&(manager->mutex_fds));
    if (manager->poll_nfds == manager->max_nfds) {
        // max filedescriptor
        pthread_mutex_unlock(&(manager->mutex_fds));
        return -1;
    }

    for (i = 0; i < manager->poll_nfds; i++) {
        if (manager->poll_fds[i].fd == fd) {
            // filedescriptor already added
            pthread_mutex_unlock(&(manager->mutex_fds));
            return -1;
        }
    }

    // init pollfd
    manager->poll_fds[manager->poll_nfds].fd = fd;
    manager->poll_fds[manager->poll_nfds].events = events;
    manager->poll_fds[manager->poll_nfds].revents = 0;

    // init fdmngr_fd_t
    manager->fds[manager->poll_nfds].poll_callback = callback;
    manager->fds[manager->poll_nfds].user_data = user_data;
    manager->fds[manager->poll_nfds].auto_closing = closing;

    // increase number of fds
    manager->poll_nfds++;
    pthread_mutex_unlock(&(manager->mutex_fds));
    return 0;
}

inline int fdmngr_remove(fdmngr_t* manager, int fd) {
    nfds_t i;

    pthread_mutex_lock(&(manager->mutex_fds));
    for (i = 0; i < manager->poll_nfds; i++) {
        if (manager->poll_fds[i].fd == fd) {
            break;
        }
    }
    if (i == manager->poll_nfds) {
        // fd not found
        pthread_mutex_unlock(&(manager->mutex_fds));
        return -1;
    }
    // close fd
    if (manager->fds[i].auto_closing == FDMNGR_AUTOMATIC_CLOSING) {
        close(manager->poll_fds[i].fd);
    }
    // move all next elements
    for (; i < manager->poll_nfds - 1; i++) {
        manager->poll_fds[i].fd = manager->poll_fds[i + 1].fd;
        manager->poll_fds[i].events = manager->poll_fds[i + 1].events;
        manager->fds[i].poll_callback = manager->fds[i + 1].poll_callback;
        manager->fds[i].user_data = manager->fds[i + 1].user_data;
        manager->fds[i].auto_closing = manager->fds[i + 1].auto_closing;
    }

    // clear last element
    manager->poll_nfds--;

    pthread_mutex_unlock(&(manager->mutex_fds));
    return 0;
}

#ifndef FDMNGR_HAVE_POLL
static inline int s_select(struct pollfd* fds, nfds_t nfds, int timeout_ms) {
    struct timeval tv;
    fd_set readfds;
    fd_set writefds;
    fd_set exceptfds;
    nfds_t i;
    int ret_poll;
    int max_fd;

    FD_ZERO(&readfds);
    FD_ZERO(&writefds);
    FD_ZERO(&exceptfds);

    max_fd = -1;
    for (i = 0; i < nfds; i++) {
        if (fds[i].fd > max_fd) {
            max_fd = fds[i].fd;
        }
        if (fds[i].events & POLLIN) {
            FD_SET(fds[i].fd, &readfds);
        }
        if (fds[i].events & POLLOUT) {
            FD_SET(fds[i].fd, &writefds);
        }
        if (fds[i].events & (POLLERR | POLLHUP | POLLNVAL)) {
            FD_SET(fds[i].fd, &exceptfds);
        }
        fds[i].revents = 0;
    }

    if (timeout_ms >= 0) {
        tv.tv_sec = timeout_ms / 1000;
        tv.tv_usec = (timeout_ms % 1000) * 1000;
    }

    ret_poll = select(max_fd + 1, &readfds, &writefds, &exceptfds,
                      (timeout_ms >= 0) ? &tv : NULL);
    if (ret_poll > 0) {
        for (i = 0; i < nfds; i++) {
            if (FD_ISSET(fds[i].fd, &readfds)) {
                fds[i].revents |= POLLIN;
            }
            if (FD_ISSET(fds[i].fd, &writefds)) {
                fds[i].revents |= POLLOUT;
            }
            if (FD_ISSET(fds[i].fd, &exceptfds)) {
                fds[i].revents |= (POLLERR | POLLHUP | POLLNVAL);
            }
        }
    }
    return ret_poll;
}
#endif

inline int fdmngr_poll(fdmngr_t* manager, int timeout_ms) {
    nfds_t i;
    int ret_poll;
    nfds_t last_poll_nfds;
    int revents;

    pthread_mutex_lock(&manager->mutex_fds);
    if (manager->poll_nfds == 0) {
        pthread_mutex_unlock(&manager->mutex_fds);
        return -1;
    }
#ifdef FDMNGR_HAVE_POLL
    ret_poll = poll(manager->poll_fds, manager->poll_nfds, timeout_ms);
#else
    ret_poll = s_select(manager->poll_fds, manager->poll_nfds, timeout_ms);
#endif
    manager->last_errno = errno;
    if (ret_poll > 0) {
        i = 0;
        last_poll_nfds = manager->poll_nfds;
        while (i < manager->poll_nfds) {
            if (manager->poll_fds[i].revents != 0) {
                revents = manager->poll_fds[i].revents;
                manager->poll_fds[i].revents = 0;
                if (manager->fds[i].poll_callback != NULL) {
                    pthread_mutex_unlock(&manager->mutex_fds);
                    manager->fds[i].poll_callback(
                        manager, manager->poll_fds[i].fd, revents,
                        manager->fds[i].user_data);
                    pthread_mutex_lock(&manager->mutex_fds);
                    if (last_poll_nfds != manager->poll_nfds) {
                        /* Restart the loop if the list has changed */
                        last_poll_nfds = manager->poll_nfds;
                        i = 0;
                        continue;
                    }
                }
            }
            ++i;
        }
    }
    pthread_mutex_unlock(&manager->mutex_fds);
    errno = manager->last_errno;
    return ret_poll;
}

// ----------------
// End src/fdmngr.c
// ----------------

#endif // #ifndef AMALGAMATE_GUARD__SINGLE_INCLUDE_FDMNGR_H_